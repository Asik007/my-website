"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7571],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=r.createContext({}),s=function(e){var t=r.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=s(e.components);return r.createElement(i.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,i=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),m=s(n),d=a,k=m["".concat(i,".").concat(d)]||m[d]||u[d]||l;return n?r.createElement(k,o(o({ref:t},c),{},{components:n})):r.createElement(k,o({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,o=new Array(l);o[0]=m;var p={};for(var i in t)hasOwnProperty.call(t,i)&&(p[i]=t[i]);p.originalType=e,p.mdxType="string"==typeof e?e:a,o[1]=p;for(var s=2;s<l;s++)o[s]=n[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2128:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return i},default:function(){return d},frontMatter:function(){return p},metadata:function(){return s},toc:function(){return u}});var r=n(7462),a=n(3366),l=(n(7294),n(3905)),o=["components"],p={layout:"default",title:"Set Drive and Telemetry",parent:"Docs",nav_order:3},i="**Set Drive and Telemetry**",s={unversionedId:"Docs/set_and_get_drive",id:"Docs/set_and_get_drive",title:"Set Drive and Telemetry",description:"{: .no_toc }",source:"@site/docs/Docs/set_and_get_drive.md",sourceDirName:"Docs",slug:"/Docs/set_and_get_drive",permalink:"/my-website/docs/Docs/set_and_get_drive",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Docs/set_and_get_drive.md",tags:[],version:"current",frontMatter:{layout:"default",title:"Set Drive and Telemetry",parent:"Docs",nav_order:3},sidebar:"tutorialSidebar",previous:{title:"PTO",permalink:"/my-website/docs/Docs/pto"},next:{title:"User Control",permalink:"/my-website/docs/Docs/user_control"}},c={},u=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"Assumed Constructor",id:"assumed-constructor",level:2},{value:"set_tank()",id:"set_tank",level:2},{value:"set_drive_brake()",id:"set_drive_brake",level:2},{value:"set_drive_current_limit()",id:"set_drive_current_limit",level:2},{value:"right_sensor()",id:"right_sensor",level:2},{value:"right_velocity()",id:"right_velocity",level:2},{value:"right_mA()",id:"right_ma",level:2},{value:"right_over_current()",id:"right_over_current",level:2},{value:"left_sensor()",id:"left_sensor",level:2},{value:"left_velocity()",id:"left_velocity",level:2},{value:"left_mA()",id:"left_ma",level:2},{value:"left_over_current()",id:"left_over_current",level:2},{value:"reset_drive_sensor()",id:"reset_drive_sensor",level:2},{value:"reset_gyro()",id:"reset_gyro",level:2},{value:"get_gyro()",id:"get_gyro",level:2},{value:"imu_calibrate()",id:"imu_calibrate",level:2}],m={toc:u};function d(e){var t=e.components,n=(0,a.Z)(e,o);return(0,l.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"set-drive-and-telemetry"},(0,l.kt)("strong",{parentName:"h1"},"Set Drive and Telemetry")),(0,l.kt)("p",null,"{: .no_toc }"),(0,l.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,l.kt)("p",null,"{: .no_toc .text-delta }"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"TOC\n{:toc}")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"assumed-constructor"},"Assumed Constructor"),(0,l.kt)("p",null,"All code below assumes this constructor is used.  As long as the name of the constructor is ",(0,l.kt)("inlineCode",{parentName:"p"},"chassis"),", any of the constructors can be used. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Chassis constructor\nDrive chassis (\n  // Left Chassis Ports (negative port will reverse it!)\n  //   the first port is the sensored port (when trackers are not used!)\n  {1, -2, 3}\n\n  // Right Chassis Ports (negative port will reverse it!)\n  //   the first port is the sensored port (when trackers are not used!)\n  ,{-4, 5, -6}\n\n  // IMU Port\n  ,7\n\n  // Wheel Diameter (Remember, 4" wheels are actually 4.125!)\n  //    (or tracking wheel diameter)\n  ,4.125\n\n  // Cartridge RPM\n  //   (or tick per rotation if using tracking wheels)\n  ,600\n\n  // External Gear Ratio (MUST BE DECIMAL)\n  //    (or gear ratio of tracking wheel)\n  // eg. if your drive is 84:36 where the 36t is powered, your RATIO would be 2.333.\n  // eg. if your drive is 36:60 where the 60t is powered, your RATIO would be 0.6.\n  ,2.333\n\n  // Uncomment if using tracking wheels\n  /*\n  // Left Tracking Wheel Ports (negative port will reverse it!)\n  ,{1, 2}\n\n  // Right Tracking Wheel Ports (negative port will reverse it!)\n  ,{3, 4}\n  */\n\n  // Uncomment if tracking wheels are plugged into a 3 wire expander\n  // 3 Wire Port Expander Smart Port\n  // ,9\n);\n\n')),(0,l.kt)("hr",null),(0,l.kt)("h1",{id:"set-drive"},"Set Drive"),(0,l.kt)("h2",{id:"set_tank"},"set_tank()"),(0,l.kt)("p",null,"Sets the drive to voltage.",(0,l.kt)("br",{parentName:"p"}),"\n",(0,l.kt)("inlineCode",{parentName:"p"},"left")," an integer between -127 and 127.",(0,l.kt)("br",{parentName:"p"}),"\n",(0,l.kt)("inlineCode",{parentName:"p"},"right")," an integer between -127 and 127.",(0,l.kt)("br",{parentName:"p"}),"\n",(0,l.kt)("strong",{parentName:"p"},"Prototype")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_tank(int left, int right);\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  set_tank(127, 127);\n  pros::delay(1000); // Wait 1 second\n  set_tank(0, 0);\n}\n")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"set_drive_brake"},"set_drive_brake()"),(0,l.kt)("p",null,"Sets brake mode for all drive motors.",(0,l.kt)("br",{parentName:"p"}),"\n",(0,l.kt)("inlineCode",{parentName:"p"},"brake_type"),"  takes either ",(0,l.kt)("inlineCode",{parentName:"p"},"MOTOR_BRAKE_COAST"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"MOTOR_BRAKE_BRAKE"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"MOTOR_BRAKE_HOLD")," as parameters.",(0,l.kt)("br",{parentName:"p"}),"\n",(0,l.kt)("strong",{parentName:"p"},"Prototype")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_drive_brake(pros::motor_brake_mode_e_t brake_type);\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"void initialize() {\n  set_drive_brake_mode(MOTOR_BRAKE_COAST);\n}\n")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"set_drive_current_limit"},"set_drive_current_limit()"),(0,l.kt)("p",null,"Sets mA limit to the drive.  Default is 2500.",(0,l.kt)("br",{parentName:"p"}),"\n",(0,l.kt)("inlineCode",{parentName:"p"},"mA"),"input miliamps.",(0,l.kt)("br",{parentName:"p"}),"\n",(0,l.kt)("strong",{parentName:"p"},"Prototype")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_drive_current_limit(int mA);\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"void initialize() {\n  set_drive_brake_mode(1000);\n}\n")),(0,l.kt)("hr",null),(0,l.kt)("h1",{id:"telemetry"},"Telemetry"),(0,l.kt)("h2",{id:"right_sensor"},"right_sensor()"),(0,l.kt)("p",null,"Returns right sensor, either integrated encoder or external encoder.",(0,l.kt)("br",{parentName:"p"}),"\n",(0,l.kt)("strong",{parentName:"p"},"Prototype")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"int right_sensor();\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'void opcontrol() {\n  while (true) {\n    chassis.tank();\n\n    printf("Right Sensor: %i \\n", chassis.right_sensor());\n\n    pros::delay(ez::util::DELAY_TIME);\n  }\n}\n')),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"right_velocity"},"right_velocity()"),(0,l.kt)("p",null,"Returns integrated encoder velocity.",(0,l.kt)("br",{parentName:"p"}),"\n",(0,l.kt)("strong",{parentName:"p"},"Prototype")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"int right_velocity();\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'void opcontrol() {\n  while (true) {\n    chassis.tank();\n\n    printf("Right Velocity: %i \\n", chassis.right_velocity());\n\n    pros::delay(ez::util::DELAY_TIME);\n  }\n}\n')),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"right_ma"},"right_mA()"),(0,l.kt)("p",null,"Returns current mA being used.",(0,l.kt)("br",{parentName:"p"}),"\n",(0,l.kt)("strong",{parentName:"p"},"Prototype")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"double right_mA();\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'void opcontrol() {\n  while (true) {\n    chassis.tank();\n\n    printf("Right mA: %i \\n", chassis.right_mA());\n\n    pros::delay(ez::util::DELAY_TIME);\n  }\n}\n')),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"right_over_current"},"right_over_current()"),(0,l.kt)("p",null,"Returns ",(0,l.kt)("inlineCode",{parentName:"p"},"true")," when the motor is over current.",(0,l.kt)("br",{parentName:"p"}),"\n",(0,l.kt)("strong",{parentName:"p"},"Prototype")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"bool right_over_current();\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'void opcontrol() {\n  while (true) {\n    chassis.tank();\n\n    printf("Right Over Current: %i \\n", chassis.right_over_current());\n\n    pros::delay(ez::util::DELAY_TIME);\n  }\n}\n')),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"left_sensor"},"left_sensor()"),(0,l.kt)("p",null,"Returns left sensor, either integrated encoder or external encoder.",(0,l.kt)("br",{parentName:"p"}),"\n",(0,l.kt)("strong",{parentName:"p"},"Prototype")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"int left_sensor();\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'void opcontrol() {\n  while (true) {\n    chassis.tank();\n\n    printf("Left Sensor: %i \\n", chassis.left_sensor());\n\n    pros::delay(ez::util::DELAY_TIME);\n  }\n}\n')),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"left_velocity"},"left_velocity()"),(0,l.kt)("p",null,"Returns integrated encoder velocity.",(0,l.kt)("br",{parentName:"p"}),"\n",(0,l.kt)("strong",{parentName:"p"},"Prototype")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"int left_velocity();\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'void opcontrol() {\n  while (true) {\n    chassis.tank();\n\n    printf("Left Velocity: %i \\n", chassis.left_velocity());\n\n    pros::delay(ez::util::DELAY_TIME);\n  }\n}\n')),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"left_ma"},"left_mA()"),(0,l.kt)("p",null,"Returns current mA being used.",(0,l.kt)("br",{parentName:"p"}),"\n",(0,l.kt)("strong",{parentName:"p"},"Prototype")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"double left_mA();\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'void opcontrol() {\n  while (true) {\n    chassis.tank();\n\n    printf("Left mA: %i \\n", chassis.left_mA());\n\n    pros::delay(ez::util::DELAY_TIME);\n  }\n}\n')),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"left_over_current"},"left_over_current()"),(0,l.kt)("p",null,"Returns ",(0,l.kt)("inlineCode",{parentName:"p"},"true")," when the motor is over current.",(0,l.kt)("br",{parentName:"p"}),"\n",(0,l.kt)("strong",{parentName:"p"},"Prototype")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"bool left_over_current();\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'void opcontrol() {\n  while (true) {\n    chassis.tank();\n\n    printf("Left Over Current: %i \\n", chassis.left_over_current());\n\n    pros::delay(ez::util::DELAY_TIME);\n  }\n}\n')),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"reset_drive_sensor"},"reset_drive_sensor()"),(0,l.kt)("p",null,"Resets integrated encoders and trackers if applicable.",(0,l.kt)("br",{parentName:"p"}),"\n",(0,l.kt)("strong",{parentName:"p"},"Prototype")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"void reset_drive_sensor();\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"void initialize() {\n  chassis.reset_drive_sensor();\n}\n")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"reset_gyro"},"reset_gyro()"),(0,l.kt)("p",null,"Sets current gyro position to parameter, defaulted to 0.",(0,l.kt)("br",{parentName:"p"}),"\n",(0,l.kt)("strong",{parentName:"p"},"Prototype")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"void reset_gyro(double new_heading = 0);\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"void initialize() {\n  chassis.reset_gyro();\n}\n")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"get_gyro"},"get_gyro()"),(0,l.kt)("p",null,"Gets IMU.",(0,l.kt)("br",{parentName:"p"}),"\n",(0,l.kt)("strong",{parentName:"p"},"Prototype")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"double get_gyro();\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'void opcontrol() {\n  while (true) {\n    chassis.tank();\n\n    printf("Gyro: %f \\n", chassis.get_gyro());\n\n    pros::delay(ez::util::DELAY_TIME);\n  }\n}\n')),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"imu_calibrate"},"imu_calibrate()"),(0,l.kt)("p",null,"Calibrates IMU, and vibrates the controler after a successful calibration.",(0,l.kt)("br",{parentName:"p"}),"\n",(0,l.kt)("strong",{parentName:"p"},"Prototype")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"bool imu_calibrate();\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"void initialize() {\n  chassis.imu_calibrate();\n}\n")),(0,l.kt)("hr",null))}d.isMDXComponent=!0}}]);