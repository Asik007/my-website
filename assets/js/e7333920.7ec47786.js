"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9554],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return _}});var s=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,s,a=function(e,t){if(null==e)return{};var n,s,a={},r=Object.keys(e);for(s=0;s<r.length;s++)n=r[s],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(s=0;s<r.length;s++)n=r[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var o=s.createContext({}),l=function(e){var t=s.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=l(e.components);return s.createElement(o.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},u=s.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,d=p(e,["components","mdxType","originalType","parentName"]),u=l(n),_=a,m=u["".concat(o,".").concat(_)]||u[_]||c[_]||r;return n?s.createElement(m,i(i({ref:t},d),{},{components:n})):s.createElement(m,i({ref:t},d))}));function _(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=u;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p.mdxType="string"==typeof e?e:a,i[1]=p;for(var l=2;l<r;l++)i[l]=n[l];return s.createElement.apply(null,i)}return s.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4627:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return o},default:function(){return _},frontMatter:function(){return p},metadata:function(){return l},toc:function(){return c}});var s=n(7462),a=n(3366),r=(n(7294),n(3905)),i=["components"],p={layout:"default",title:"Autonomous Functions",parent:"Docs",nav_order:4},o="**Autonomous Functions**",l={unversionedId:"Docs/auton_functions",id:"Docs/auton_functions",title:"Autonomous Functions",description:"Assumed Constructor",source:"@site/docs/Docs/auton_functions.md",sourceDirName:"Docs",slug:"/Docs/auton_functions",permalink:"/my-website/docs/Docs/auton_functions",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Docs/auton_functions.md",tags:[],version:"current",frontMatter:{layout:"default",title:"Autonomous Functions",parent:"Docs",nav_order:4},sidebar:"tutorialSidebar",previous:{title:"Docs",permalink:"/my-website/docs/category/docs"},next:{title:"Autonomous Selector",permalink:"/my-website/docs/Docs/auton_selector"}},d={},c=[{value:"Assumed Constructor",id:"assumed-constructor",level:2},{value:"Setter functions",id:"setter-functions",level:2},{value:"set_drive_pid()",id:"set_drive_pid",level:3},{value:"set_turn_pid()",id:"set_turn_pid",level:3},{value:"set_swing_pid()",id:"set_swing_pid",level:3},{value:"reset_pid_targets()",id:"reset_pid_targets",level:3},{value:"set_angle()",id:"set_angle",level:3},{value:"set_max_speed()",id:"set_max_speed",level:3},{value:"set_pid_constants()",id:"set_pid_constants",level:3},{value:"set_slew_min_power()",id:"set_slew_min_power",level:3},{value:"set_slew_distance()",id:"set_slew_distance",level:3},{value:"set_exit_condition()",id:"set_exit_condition",level:3},{value:"set_swing_min()",id:"set_swing_min",level:3},{value:"set_turn_min()",id:"set_turn_min",level:3},{value:"set_mode()",id:"set_mode",level:3},{value:"toggle_auto_drive()",id:"toggle_auto_drive",level:3},{value:"toggle_auto_print()",id:"toggle_auto_print",level:3},{value:"Getter",id:"getter",level:2},{value:"get_swing_min()",id:"get_swing_min",level:3},{value:"get_turn_min()",id:"get_turn_min",level:3},{value:"interfered",id:"interfered",level:3},{value:"get_mode()",id:"get_mode",level:3},{value:"get_tick_per_inch()",id:"get_tick_per_inch",level:3},{value:"Misc.",id:"misc",level:2},{value:"wait_drive()",id:"wait_drive",level:3},{value:"wait_until()",id:"wait_until",level:3}],u={toc:c};function _(e){var t=e.components,n=(0,a.Z)(e,i);return(0,r.kt)("wrapper",(0,s.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"autonomous-functions"},(0,r.kt)("strong",{parentName:"h1"},"Autonomous Functions")),(0,r.kt)("h2",{id:"assumed-constructor"},"Assumed Constructor"),(0,r.kt)("p",null,"All code below assumes this constructor is used.  As long as the name of the constructor is ",(0,r.kt)("inlineCode",{parentName:"p"},"chassis"),", any of the constructors can be used. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// Chassis constructor\nDrive chassis (\n  // Left Chassis Ports (negative port will reverse it!)\n  //   the first port is the sensored port (when trackers are not used!)\n  {1, -2, 3}\n\n  // Right Chassis Ports (negative port will reverse it!)\n  //   the first port is the sensored port (when trackers are not used!)\n  ,{-4, 5, -6}\n\n  // IMU Port\n  ,7\n\n  // Wheel Diameter (Remember, 4" wheels are actually 4.125!)\n  //    (or tracking wheel diameter)\n  ,4.125\n\n  // Cartridge RPM\n  //   (or tick per rotation if using tracking wheels)\n  ,600\n\n  // External Gear Ratio (MUST BE DECIMAL)\n  //    (or gear ratio of tracking wheel)\n  // eg. if your drive is 84:36 where the 36t is powered, your RATIO would be 2.333.\n  // eg. if your drive is 36:60 where the 60t is powered, your RATIO would be 0.6.\n  ,2.333\n\n  // Uncomment if using tracking wheels\n  /*\n  // Left Tracking Wheel Ports (negative port will reverse it!)\n  ,{1, 2}\n\n  // Right Tracking Wheel Ports (negative port will reverse it!)\n  ,{3, 4}\n  */\n\n  // Uncomment if tracking wheels are plugged into a 3 wire expander\n  // 3 Wire Port Expander Smart Port\n  // ,9\n);\n\n')),(0,r.kt)("h2",{id:"setter-functions"},"Setter functions"),(0,r.kt)("h3",{id:"set_drive_pid"},"set_drive_pid()"),(0,r.kt)("p",null,"Sets the drive to go forward using PID and heading correction.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"target")," is in inches.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"speed")," is -127 to 127.  It's recommended to keep this at 110.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"slew_on")," will ramp the drive up.\n",(0,r.kt)("inlineCode",{parentName:"p"},"toggle_heading")," will disable heading correction when false.\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_drive_pid(double target, int speed, bool slew_on = false, bool toggle_heading = true);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.reset_gyro(); \n  chassis.reset_drive_sensor(); \n  chassis.set_drive_brake(MOTOR_BRAKE_HOLD); \n\n  chassis.set_drive_pid(24, 110, true);\n  chassis.wait_drive();\n}\n")),(0,r.kt)("h3",{id:"set_turn_pid"},"set_turn_pid()"),(0,r.kt)("p",null,"Sets the drive to turn using PID.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"target")," is in degrees.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"speed")," is -127 to 127.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_turn_pid(double target, int speed);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.reset_gyro(); \n  chassis.reset_drive_sensor(); \n  chassis.set_drive_brake(MOTOR_BRAKE_HOLD); \n\n  chassis.set_turn_pid(90, 110);\n  chassis.wait_drive();\n}\n")),(0,r.kt)("h3",{id:"set_swing_pid"},"set_swing_pid()"),(0,r.kt)("p",null,"Sets the robot to swing using PID.  The robot will turn using one side of the drive, either the left or right.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"type")," is either ",(0,r.kt)("inlineCode",{parentName:"p"},"ez::LEFT_SWING")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"ez::RIGHT_SWING"),".",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"target")," is in degrees.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"speed")," is -127 to 127.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_swing_pid(e_swing type, double target, int speed);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.reset_gyro(); \n  chassis.reset_drive_sensor(); \n  chassis.set_drive_brake(MOTOR_BRAKE_HOLD); \n\n  chassis.set_swing_pid(ez::LEFT_SWING, 45, 110);\n  chassis.wait_drive();\n\n  chassis.set_swing_pid(ez::RIGHT_SWING, 0, 110);\n  chassis.wait_drive();\n}\n")),(0,r.kt)("h3",{id:"reset_pid_targets"},"reset_pid_targets()"),(0,r.kt)("p",null,"Resets all drive PID targets to 0.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void reset_pid_targets();\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.reset_pid_targets(); // Resets PID targets to 0\n  chassis.reset_gyro(); // Reset gyro position to 0\n  chassis.reset_drive_sensor(); // Reset drive sensors to 0\n  chassis.set_drive_brake(MOTOR_BRAKE_HOLD); // Set motors to hold.  This helps autonomous consistency.\n\n  ez::as::auton_selector.call_selected_auton(); // Calls selected auton from autonomous selector.\n}\n")),(0,r.kt)("h3",{id:"set_angle"},"set_angle()"),(0,r.kt)("p",null,"Sets the angle of the robot.  This is useful when your robot is setup in at an unconventional angle and you want 0 to be when you're square with the field.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_angle(double angle);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.reset_pid_targets(); // Resets PID targets to 0\n  chassis.reset_gyro(); // Reset gyro position to 0\n  chassis.reset_drive_sensor(); // Reset drive sensors to 0\n  chassis.set_drive_brake(MOTOR_BRAKE_HOLD); // Set motors to hold.  This helps autonomous consistency.\n\n  chassis.set_angle(45);\n\n  chassis.set_turn_pid(0, TURN_SPEED);\n  chassis.wait_drive();\n}\n")),(0,r.kt)("h3",{id:"set_max_speed"},"set_max_speed()"),(0,r.kt)("p",null,"Sets the max speed of the drive.\n",(0,r.kt)("inlineCode",{parentName:"p"},"speed")," an integer between -127 and 127.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_max_speed(int speed);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.reset_gyro(); \n  chassis.reset_drive_sensor(); \n  chassis.set_drive_brake(MOTOR_BRAKE_HOLD); \n\n  chassis.set_drive_pid(48, 110);\n  chassis.wait_until(24);\n  chassis.set_max_speed(40);\n  chassis.wait_drive();\n}\n")),(0,r.kt)("h3",{id:"set_pid_constants"},"set_pid_constants()"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Note: this function was changed with 2.0.1"),(0,r.kt)("br",{parentName:"p"}),"\n","Set PID constants.  Below are the defaults.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"pid")," either ",(0,r.kt)("inlineCode",{parentName:"p"},"&chassis.headingPID"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"&chassis.forward_drivePID"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"&chassis.backward_drivePID"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"&chassis.turnPID"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"&chassis.swingPID"),".",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"p")," proportion constant.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"i")," integral constant.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"d")," derivative constant.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"p_start_i")," error needs to be within this for i to start.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_pid_constants(PID* pid, double p, double i, double d, double p_start_i);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void initialize() {\n  chassis.set_pid_constants(&chassis.headingPID, 11, 0, 20, 0);\n  chassis.set_pid_constants(&chassis.forward_drivePID, 0.45, 0, 5, 0);\n  chassis.set_pid_constants(&chassis.backward_drivePID, 0.45, 0, 5, 0);\n  chassis.set_pid_constants(&chassis.turnPID, 5, 0.003, 35, 15;\n  chassis.set_pid_constants(&chassis.swingPID, 7, 0, 45, 0);\n}\n")),(0,r.kt)("h3",{id:"set_slew_min_power"},"set_slew_min_power()"),(0,r.kt)("p",null,"Sets the starting speed for slew, with the ability to have different constants for forward and reverse.  Below is the defaults.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"fwd")," integer between -127 and 127.\n",(0,r.kt)("inlineCode",{parentName:"p"},"rev")," integer between -127 and 127.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_slew_min_power(int fwd, int rev);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void initialize() {\n  chassis.set_slew_min_power(80, 80);\n}\n")),(0,r.kt)("h3",{id:"set_slew_distance"},"set_slew_distance()"),(0,r.kt)("p",null,"Sets the distance the drive will slew for, with the ability to have different constants for forward and reverse.  Input is inches.  Below is the defaults.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"fwd")," a distance in inches.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"rev")," a distance in inches.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_slew_distance (int fwd, int rev);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void initialize() {\n  chassis.set_slew_min_distance(7, 7);\n}\n")),(0,r.kt)("h3",{id:"set_exit_condition"},"set_exit_condition()"),(0,r.kt)("p",null,"Sets the exit condition constants. This uses the exit conditions from the PID class.  Below is the defaults.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"type")," either ",(0,r.kt)("inlineCode",{parentName:"p"},"chassis.turn_exit"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"chassis.swing_exit"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"chassis.drive_exit"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"p_small_exit_time")," time, in ms, before exiting ",(0,r.kt)("inlineCode",{parentName:"p"},"p_small_error"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"p_small_error")," small error threshold",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"p_big_exit_time")," time, in ms, before exiting ",(0,r.kt)("inlineCode",{parentName:"p"},"p_big_error"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"p_big_error")," big error threshold",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"p_velocity_exit_time")," time, in ms, for velocity to be 0",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"p_mA_timeout")," time, in ms, for ",(0,r.kt)("inlineCode",{parentName:"p"},"is_over_current")," to be true",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_exit_condition(exit_condition_ &type, int p_small_exit_time, double p_small_error, int p_big_exit_time, double p_big_error, int p_velocity_exit_time, int p_mA_timeout);\n\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void initialize() {\n  chassis.set_exit_condition(chassis.turn_exit,  100, 3,  500, 7,   500, 500);\n  chassis.set_exit_condition(chassis.swing_exit, 100, 3,  500, 7,   500, 500);\n  chassis.set_exit_condition(chassis.drive_exit, 80,  50, 300, 150, 500, 500);\n}\n")),(0,r.kt)("h3",{id:"set_swing_min"},"set_swing_min()"),(0,r.kt)("p",null,"Sets the max power of the drive when the robot is within ",(0,r.kt)("inlineCode",{parentName:"p"},"start_i"),".  This only enalbes when ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," is enabled, and when the movement is greater then ",(0,r.kt)("inlineCode",{parentName:"p"},"start_i"),".",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_swing_min(int min);\n\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.set_swing_min(30);\n\n  chassis.set_swing_pid(45, 110);\n  chassis.wait_drive();\n}\n")),(0,r.kt)("h3",{id:"set_turn_min"},"set_turn_min()"),(0,r.kt)("p",null,"Sets the max power of the drive when the robot is within ",(0,r.kt)("inlineCode",{parentName:"p"},"start_i"),".  This only enalbes when ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," is enabled, and when the movement is greater then ",(0,r.kt)("inlineCode",{parentName:"p"},"start_i"),".",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_turn_min(int min);\n\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.set_turn_min(30);\n\n  chassis.set_turn_pid(45, 110);\n  chassis.wait_drive();\n}\n")),(0,r.kt)("h3",{id:"set_mode"},"set_mode()"),(0,r.kt)("p",null,"Sets the current mode of the drive.  Accepts ",(0,r.kt)("inlineCode",{parentName:"p"},"ez::DISABLE"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ez::SWING"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ez::TURN"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ez::DRIVE"),".",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void set_mode(e_mode p_mode);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.set_drive_pid(12, DRIVE_SPEED);\n  chassis.wait_drive();\n\n  chassis.set_mode(ez::DISABLE); // Disable drive\n\n  chassis.set_tank(-127, -127); // Run drive motors myself\n  pros::delay(2000);\n  chassis.set_tank(0, 0);\n}\n")),(0,r.kt)("h3",{id:"toggle_auto_drive"},"toggle_auto_drive()"),(0,r.kt)("p",null,"Enables/disables the drive from moving in autonomous.  This is useful for debugging and checking PID variables.  True enables, false disables.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void toggle_auto_drive(bool toggle);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'void autonomous() {\n  chassis.set_drive_pid(12, DRIVE_SPEED);\n  chassis.wait_drive();\n\n  toggle_auto_drive(false); // Disable drive\n\n  chassis.set_drive_pid(-12, DRIVE_SPEED);\n  while (true) {\n    printf(" Left Error: %f  Right Error: %f\\n", chassis.leftPID.error, chassis.rightPID.error);\n    pros::delay(ez::util::DELAY_TIME);\n  }\n}\n')),(0,r.kt)("h3",{id:"toggle_auto_print"},"toggle_auto_print()"),(0,r.kt)("p",null,"Enables/disables the drive functions printing every drive motion.  This is useful when you're debugging something and don't want terminal cluttered.  True enables, false disables.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void toggle_auto_print(bool toggle);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.set_drive_pid(12, DRIVE_SPEED); // This will print\n  chassis.wait_drive(); // This will print\n\n  toggle_auto_print(false); // Disable prints\n\n  chassis.set_drive_pid(-12, DRIVE_SPEED); // This won't print\n  chassis.wait_drive(); // This won't print\n}\n")),(0,r.kt)("h2",{id:"getter"},"Getter"),(0,r.kt)("h3",{id:"get_swing_min"},"get_swing_min()"),(0,r.kt)("p",null,"Returns swing min.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int get_swing_min();\n\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'void autonomous() {\n  chassis.set_swing_min(30);\n\n  printf("Swing Min: %i", chassis.get_swing_min());\n}\n')),(0,r.kt)("h3",{id:"get_turn_min"},"get_turn_min()"),(0,r.kt)("p",null,"Returns turn min.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int get_turn_min();\n\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'void autonomous() {\n  chassis.set_turn_min(30);\n\n  printf("Turn Min: %i", chassis.get_turn_min());\n}\n')),(0,r.kt)("h3",{id:"interfered"},"interfered"),(0,r.kt)("p",null,"Boolean that returns true when ",(0,r.kt)("inlineCode",{parentName:"p"},"wait_drive()")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"wait_until()")," exit with velocity or is_over_current.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"bool interfered = false;\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},' void tug (int attempts) {\n   for (int i=0; i<attempts-1; i++) {\n     // Attempt to drive backwards\n     printf("i - %i", i);\n     chassis.set_drive_pid(-12, 127);\n     chassis.wait_drive();\n\n     // If failsafed...\n     if (chassis.interfered) {\n       chassis.reset_drive_sensor();\n       chassis.set_drive_pid(-2, 20);\n       pros::delay(1000);\n     }\n     // If robot successfully drove back, return\n     else {\n       return;\n     }\n   }\n }\n\nvoid auto1() {\n  chassis.set_drive_pid(24, 110, true);\n  chassis.wait_drive();\n\n  if (chassis.interfered) {\n    tug(3);\n    return;\n  }\n\n  chassis.set_turn_pid(90, 90);\n  chassis.wait_drive();\n}\n')),(0,r.kt)("h3",{id:"get_mode"},"get_mode()"),(0,r.kt)("p",null,"Returns the current drive mode.  Returns ",(0,r.kt)("inlineCode",{parentName:"p"},"ez::DISABLE"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ez::SWING"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ez::TURN"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ez::DRIVE"),".",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"e_mode get_mode();\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.set_drive_pid(12, DRIVE_SPEED);\n  chassis.wait_drive();\n\n  if (chassis.interfered)\n    chassis.set_mode(ez::DISABLE);\n  \n  if (chassis.get_mode() == ez::DISABLE) {\n    chassis.set_tank(-127, -127); // Run drive motors myself\n    pros::delay(2000);\n    chassis.set_tank(0, 0);\n  }\n}\n")),(0,r.kt)("h3",{id:"get_tick_per_inch"},"get_tick_per_inch()"),(0,r.kt)("p",null,"Returns current tick per inch.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"double get_tick_per_inch();\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'void initialize() {\n  printf("Tick Per Inch: %f\\n", chassis.get_tick_per_inch());\n}\n')),(0,r.kt)("h2",{id:"misc"},"Misc."),(0,r.kt)("h3",{id:"wait_drive"},"wait_drive()"),(0,r.kt)("p",null,"Locks the code in place until the drive has settled.  This uses the exit conditions from the PID class.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void wait_drive();\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.reset_gyro(); \n  chassis.reset_drive_sensor(); \n  chassis.set_drive_brake(MOTOR_BRAKE_HOLD); \n\n  chassis.set_turn_pid(90, 110);\n  chassis.wait_drive();\n\n  chassis.set_turn_pid(0, 110);\n  chassis.wait_drive();\n}\n")),(0,r.kt)("h3",{id:"wait_until"},"wait_until()"),(0,r.kt)("p",null,"Locks the code in place until the drive has passed the input parameter.  This uses the exit conditions from the PID class.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Prototype")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void wait_until(double target);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void autonomous() {\n  chassis.reset_gyro(); \n  chassis.reset_drive_sensor(); \n  chassis.set_drive_brake(MOTOR_BRAKE_HOLD); \n\n  chassis.set_drive_pid(48, 110);\n  chassis.wait_until(24);\n  chassis.set_max_speed(40);\n  chassis.wait_drive();\n}\n")))}_.isMDXComponent=!0}}]);